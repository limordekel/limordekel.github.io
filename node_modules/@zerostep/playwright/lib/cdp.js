"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeScript = exports.getCurrentUrl = exports.querySelectorAll = exports.findElements = exports.getElementRect = exports.focusElement = exports.getContentQuads = exports.clickElement = exports.getElementTagName = exports.getElementAttribute = exports.sendKeysToElement = exports.clearElement = exports.getLayoutMetrics = exports.getDOMSnapshot = exports.runFunctionOn = exports.scrollElement = exports.get = exports.getTitle = exports.scrollIntoView = exports.getScreenshot = exports.getCDPSession = exports.detachCPDSession = void 0;
const config_js_1 = require("./config.js");
let cdpSessionByPage = new Map();
/**
 * Closes the cdp session and clears the global shared reference. This
 * happens automatically when a page closes in a playwright test, so
 * should generally not be necessary.
 */
const detachCPDSession = async (page) => {
    if (cdpSessionByPage.has(page)) {
        await cdpSessionByPage.get(page).detach();
        cdpSessionByPage.delete(page);
    }
};
exports.detachCPDSession = detachCPDSession;
/**
 * Returns a stable reference to a CDP session.
 */
const getCDPSession = async (page) => {
    if (!cdpSessionByPage.has(page)) {
        try {
            const session = await page.context().newCDPSession(page);
            cdpSessionByPage.set(page, session);
        }
        catch (e) {
            throw Error('The ai() function can only be run against Chromium browsers.');
        }
    }
    return cdpSessionByPage.get(page);
};
exports.getCDPSession = getCDPSession;
const getScreenshot = async (page) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const screenshot = await cdpSession.send('Page.captureScreenshot');
    return screenshot.data; // Base64-encoded image data
};
exports.getScreenshot = getScreenshot;
const scrollIntoView = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    await cdpSession.send('DOM.scrollIntoViewIfNeeded', {
        backendNodeId: parseInt(args.id)
    });
};
exports.scrollIntoView = scrollIntoView;
const getTitle = async (page) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const returnedValue = await cdpSession.send('Runtime.evaluate', {
        expression: 'document.title',
        returnByValue: true,
    });
    return returnedValue.result.value;
};
exports.getTitle = getTitle;
const get = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    await cdpSession.send('Page.navigate', {
        url: args.url
    });
};
exports.get = get;
const scrollElement = async (page, args) => {
    await (0, exports.runFunctionOn)(page, {
        functionDeclaration: `function() {
      let element = this
      let elementHeight = 0

      switch (element.tagName) {
        case 'BODY':
        case 'HTML':
          element = document.scrollingElement || document.body
          elementHeight = window.visualViewport?.height ?? 720
          break
        default:
          elementHeight = element.clientHeight ?? 720
          break
      }

      const relativeScrollDistance = 0.75 * elementHeight

      switch ("${args.target}") {
        case 'top':
          return element.scrollTo({ top: 0 })
        case 'bottom':
          return element.scrollTo({ top: element.scrollHeight })
        case 'up':
          return element.scrollBy({ top: -relativeScrollDistance })
        case 'down':
          return element.scrollBy({ top: relativeScrollDistance })
        default:
          throw Error('Unsupported scroll target ${args.target}')
      }
    }`,
        backendNodeId: parseInt(args.id),
    });
};
exports.scrollElement = scrollElement;
const runFunctionOn = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const { object: { objectId } } = await cdpSession.send('DOM.resolveNode', { backendNodeId: args.backendNodeId });
    await cdpSession.send('Runtime.callFunctionOn', {
        functionDeclaration: args.functionDeclaration,
        objectId,
    });
};
exports.runFunctionOn = runFunctionOn;
const getDOMSnapshot = async (page) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const returnValue = await cdpSession.send('DOMSnapshot.captureSnapshot', {
        computedStyles: ['background-color', 'visibility', 'opacity', 'z-index', 'overflow'],
        includePaintOrder: true,
        includeDOMRects: true,
    });
    return returnValue;
};
exports.getDOMSnapshot = getDOMSnapshot;
const getLayoutMetrics = async (page) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const returnValue = await cdpSession.send('Page.getLayoutMetrics');
    return returnValue;
};
exports.getLayoutMetrics = getLayoutMetrics;
const clearElement = async (page, args) => {
    return await (0, exports.runFunctionOn)(page, {
        functionDeclaration: `function() {this.value=''}`,
        backendNodeId: parseInt(args.id),
    });
};
exports.clearElement = clearElement;
const sendKeysToElement = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const value = args.value[0];
    const { nodeId } = await cdpSession.send('DOM.requestNode', { objectId: args.id });
    await cdpSession.send('DOM.focus', { nodeId: nodeId });
    for (let i = 0; i < value.length; i++) {
        await cdpSession.send('Input.dispatchKeyEvent', {
            type: 'char',
            text: value[i],
        });
    }
    return true;
};
exports.sendKeysToElement = sendKeysToElement;
const getElementAttribute = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const { nodeId } = await cdpSession.send('DOM.requestNode', { objectId: args.id });
    const { attributes } = await cdpSession.send('DOM.getAttributes', { nodeId: nodeId });
    for (let i = 0; i < attributes.length; i++) {
        if (attributes[i] === args.name) {
            return attributes[i + 1];
        }
    }
};
exports.getElementAttribute = getElementAttribute;
const getElementTagName = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const returnedValue = await cdpSession.send('Runtime.callFunctionOn', {
        functionDeclaration: `function() {return this.tagName}`,
        objectId: args.id,
        returnByValue: true,
    });
    return returnedValue.result.value;
};
exports.getElementTagName = getElementTagName;
const clickElement = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const { centerX, centerY } = await (0, exports.getContentQuads)(page, { backendNodeId: parseInt(args.id) });
    await cdpSession.send('Input.dispatchMouseEvent', {
        type: 'mousePressed',
        x: centerX,
        y: centerY,
        button: 'left',
        clickCount: 1,
        buttons: 1,
    });
    await cdpSession.send('Input.dispatchMouseEvent', {
        type: 'mouseReleased',
        x: centerX,
        y: centerY,
        button: 'left',
        clickCount: 1,
        buttons: 1,
    });
    return true;
};
exports.clickElement = clickElement;
const getContentQuads = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const quadsResponse = await cdpSession.send('DOM.getContentQuads', args);
    const [topLeftX, topLeftY, topRightX, topRightY, bottomRightX, bottomRightY, bottomLeftX, bottomLeftY,] = quadsResponse.quads[0];
    const width = topRightX - topLeftX;
    const height = bottomRightY - topRightY;
    const centerX = topLeftX + (width / 2);
    const centerY = topRightY + (height / 2);
    return {
        topLeftX, topLeftY,
        topRightX, topRightY,
        bottomRightX, bottomRightY,
        bottomLeftX, bottomLeftY,
        width, height,
        centerX, centerY,
    };
};
exports.getContentQuads = getContentQuads;
const focusElement = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    await cdpSession.send('DOM.focus', args);
};
exports.focusElement = focusElement;
const getElementRect = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const returnedValue = await cdpSession.send('Runtime.callFunctionOn', {
        functionDeclaration: `function() {return JSON.parse(JSON.stringify(this.getBoundingClientRect()))}`,
        objectId: args.id,
        returnByValue: true,
    });
    return returnedValue.result.value;
};
exports.getElementRect = getElementRect;
const findElements = async (page, args) => {
    switch (args.using) {
        case 'css selector':
        case 'tag name':
            return await (0, exports.querySelectorAll)(page, { selector: args.value });
        default:
            throw Error(`Unsupported findElements strategy ${args.using}`);
    }
};
exports.findElements = findElements;
const querySelectorAll = async (page, args) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const rootDocumentNode = await cdpSession.send('DOM.getDocument', { depth: -1 });
    const returned = await cdpSession.send('DOM.querySelectorAll', { nodeId: rootDocumentNode.root.nodeId, selector: args.selector });
    const resolvedNodesPromises = returned.nodeIds.map(async (nodeId) => await cdpSession.send('DOM.resolveNode', { nodeId: nodeId }));
    const resolvedNodes = await Promise.all(resolvedNodesPromises);
    const returnValue = resolvedNodes.map((node) => ({ [config_js_1.WEBDRIVER_ELEMENT_KEY]: node.object.objectId }));
    return returnValue;
};
exports.querySelectorAll = querySelectorAll;
const getCurrentUrl = async (page) => {
    const cdpSession = await (0, exports.getCDPSession)(page);
    const returned = await cdpSession.send('Page.getNavigationHistory');
    const returnValue = returned.entries[returned.currentIndex].url;
    return returnValue;
};
exports.getCurrentUrl = getCurrentUrl;
const executeScript = async (page, args) => {
    const functionDeclaration = `function() { ${args.script} }`;
    const functionArgs = args.args.map((arg) => {
        if (typeof arg === 'boolean' || typeof arg === 'string' || typeof arg === 'number') {
            return { value: arg };
        }
        else if (arg && typeof arg === 'object' && Reflect.has(arg, config_js_1.WEBDRIVER_ELEMENT_KEY)) {
            return { objectId: arg[config_js_1.WEBDRIVER_ELEMENT_KEY] };
        }
        else {
            return { value: undefined };
        }
    });
    const cdpSession = await (0, exports.getCDPSession)(page);
    await cdpSession.send('Runtime.enable');
    const window = await cdpSession.send('Runtime.evaluate', { expression: 'window' });
    const returnedRef = await cdpSession.send('Runtime.callFunctionOn', {
        objectId: window.result.objectId,
        functionDeclaration,
        arguments: functionArgs,
    });
    if (returnedRef.result.className === 'NodeList') {
        const nodeProperties = await cdpSession.send('Runtime.getProperties', {
            objectId: returnedRef.result.objectId,
            ownProperties: true,
        });
        return nodeProperties.result.map((e) => !isNaN(parseInt(e.name)) ? { [config_js_1.WEBDRIVER_ELEMENT_KEY]: e.value?.objectId } : null).filter(e => e);
    }
    else if (returnedRef.result.className === 'HTMLHtmlElement') {
        return { [config_js_1.WEBDRIVER_ELEMENT_KEY]: returnedRef.result.objectId };
    }
    else {
        const returnedValue = await cdpSession.send('Runtime.callFunctionOn', {
            objectId: window.result.objectId,
            functionDeclaration,
            arguments: functionArgs,
            returnByValue: true,
        });
        return returnedValue.result.value;
    }
};
exports.executeScript = executeScript;
//# sourceMappingURL=cdp.js.map