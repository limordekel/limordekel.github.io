"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.aiFixture = exports.ai = void 0;
const uuidv7_1 = require("uuidv7");
const cdp = __importStar(require("./cdp.js"));
const playwright = __importStar(require("./playwright.js"));
const webSocket = __importStar(require("./webSocket.js"));
const meta = __importStar(require("./meta.js"));
const config_js_1 = require("./config.js");
/**
 * Executes the provided plain-english task. If an array of tasks is provided
 * as the first argument, tasks will be bundled according to the options.parallelism
 * value (default=10) and executed in parallel. The promise will resolve once all
 * provided tasks have completed
 */
const ai = async (task, config, options) => {
    if (!config || !config.page || !config.test) {
        throw Error('The ai() function is missing the required `{ page, test }` argument.');
    }
    else if (Array.isArray(task)) {
        return runInParallel(task, config, options);
    }
    // Generate a unique ID that all messages in this exchange will use
    const taskId = (0, uuidv7_1.uuidv7)();
    const { test, page } = config;
    return new Promise((resolve, reject) => {
        test.step(`${config_js_1.PACKAGE_NAME}.ai '${task}'`, async () => {
            if (!config_js_1.TOKEN) {
                reject(makeErrorMessage('The $ZEROSTEP_TOKEN environment variable or a zerostep.config.json file with a '
                    + '"TOKEN" field must be defined to execute ai steps. You can '
                    + 'find your token or sign up for an account at https://app.zerostep.com'));
                return;
            }
            else if (task.length > config_js_1.MAX_TASK_CHARS) {
                reject(makeErrorMessage(`Provided task string is too long, max length is ${config_js_1.MAX_TASK_CHARS} chars`));
                return;
            }
            await sendTaskStartMessage(page, task, taskId, options);
            const taskCompleteResponse = await runCommandsToCompletion(page, test, taskId);
            const taskResult = taskCompleteResponse.result;
            if (options?.debug) {
                resolve(taskCompleteResponse);
            }
            else if (taskCompleteResponse.errorMessage) {
                reject(makeErrorMessage(taskCompleteResponse.errorMessage, taskId));
            }
            else if (!taskResult && taskCompleteResponse.wasSuccessful === false) {
                reject(makeErrorMessage('An unknown error occurred when trying to run the ai step', taskId));
            }
            else if (!taskResult) {
                resolve(undefined);
            }
            else if (taskResult.assertion !== undefined) {
                resolve(taskResult.assertion);
            }
            else if (taskResult.query !== undefined) {
                resolve(taskResult.query);
            }
            else if (taskResult.actions !== undefined && taskCompleteResponse.wasSuccessful === false) {
                reject(makeErrorMessage('Could not execute ai step as action', taskId));
            }
            else {
                resolve(undefined);
            }
        });
    }).catch((e) => {
        return test.step(e, async () => {
            console.error(e);
            throw e;
        });
    });
};
exports.ai = ai;
/**
 * A helper function to generate a playwright fixture for ai(). Can be used in
 * a playwright setup
 */
const aiFixture = (test) => {
    return {
        ai: async ({ page }, use) => {
            const wrapped = async (task, options) => {
                return await (0, exports.ai)(task, { test, page: page }, options);
            };
            use(wrapped);
        }
    };
};
exports.aiFixture = aiFixture;
const makeErrorMessage = (message, taskId) => {
    const prefix = `${config_js_1.PACKAGE_NAME}.error '${message}'. Version:${meta.getVersion()}`;
    if (taskId) {
        return prefix + ` TaskId:${taskId}`;
    }
    else {
        return prefix;
    }
};
/**
 * Sends a message over the websocket to begin an AI task.
 */
const sendTaskStartMessage = async (page, task, taskId, options) => {
    const snapshot = await playwright.getSnapshot(page);
    const message = {
        type: 'task-start',
        packageVersion: meta.getVersion(),
        taskId,
        task,
        snapshot,
        options,
    };
    await webSocket.sendWebSocketMessage(message);
};
/**
 * Sends a message over the websocket in response to an AI command completing.
 */
const sendCommandResolveMessage = async (index, taskId, result) => {
    const message = {
        type: 'command-response',
        packageVersion: meta.getVersion(),
        taskId,
        index,
        result: result === undefined || result === null ? "null" : JSON.stringify(result),
    };
    await webSocket.sendWebSocketMessage(message);
};
/**
 * Listens for websocket commands, executes them, then responds in a promise that
 * is resolved once we see the task-complete message.
 */
const runCommandsToCompletion = async (page, test, taskId) => {
    return new Promise((resolve) => {
        webSocket.addWebSocketMessageHandler(taskId, (data, removeListener) => {
            // Only respond to messages corresponding to the task for which this
            // listener was bound.
            if (!data.taskId || data.taskId === taskId) {
                switch (data.type) {
                    case 'command-request':
                        const prettyCommandName = getPrettyCommandName(data.name);
                        test.step(`${config_js_1.PACKAGE_NAME}.action ${prettyCommandName}`, async () => {
                            const result = await executeCommand(page, data);
                            await sendCommandResolveMessage(data.index, taskId, result);
                        });
                        break;
                    case 'task-complete':
                        removeListener();
                        // If there was a response in the completion, print it as
                        // a test step in the actions list.
                        if (data.result?.assertion !== undefined) {
                            test.step(`${config_js_1.PACKAGE_NAME}.assertion ${data.result.assertion}`, async () => {
                                resolve(data);
                            });
                        }
                        else if (data.result?.query !== undefined) {
                            test.step(`${config_js_1.PACKAGE_NAME}.response ${data.result.query}`, async () => {
                                resolve(data);
                            });
                        }
                        else {
                            resolve(data);
                        }
                        break;
                }
            }
        });
    });
};
/**
 * Executes a webdriver command passed over the websocket using CDP.
 */
const executeCommand = async (page, command) => {
    switch (command.name) {
        // CDP
        case 'getDOMSnapshot':
            return await cdp.getDOMSnapshot(page);
        case 'executeScript':
            return await cdp.executeScript(page, command.arguments);
        case 'getCurrentUrl':
            return await cdp.getCurrentUrl(page);
        case 'findElements':
            return await cdp.findElements(page, command.arguments);
        case 'getElementTagName':
            return await cdp.getElementTagName(page, command.arguments);
        case 'getElementRect':
            return await cdp.getElementRect(page, command.arguments);
        case 'getElementAttribute':
            return await cdp.getElementAttribute(page, command.arguments);
        case 'clearElement':
            return await cdp.clearElement(page, command.arguments);
        case 'get':
            return await cdp.get(page, command.arguments);
        case 'getTitle':
            return await cdp.getTitle(page);
        case 'scrollIntoView':
            return await cdp.scrollIntoView(page, command.arguments);
        case 'currentUrl':
            return await cdp.getCurrentUrl(page);
        // Queries
        case 'snapshot':
            return await playwright.getSnapshot(page);
        // Actions using CDP Element
        case 'clickElement':
            return await playwright.clickCDPElement(page, command.arguments);
        case 'sendKeysToElement':
            return await playwright.clickAndInputCDPElement(page, command.arguments);
        case 'hoverElement':
            return await playwright.hoverCDPElement(page, command.arguments);
        case 'scrollElement':
            return await cdp.scrollElement(page, command.arguments);
        // Actions using Location
        case 'clickLocation':
            return await playwright.clickLocation(page, command.arguments);
        case 'hoverLocation':
            return await playwright.hoverLocation(page, command.arguments);
        case 'clickAndInputLocation':
            return await playwright.clickAndInputLocation(page, command.arguments);
        case 'getElementAtLocation':
            return await playwright.getElementAtLocation(page, command.arguments);
        // Actions using Device
        case 'sendKeys':
            return await playwright.input(page, command.arguments);
        case 'keypressEnter':
            return await playwright.keypressEnter(page);
        case 'navigate':
            return await playwright.navigate(page, command.arguments);
        // Actions using Script
        case 'scrollPage':
            return await playwright.scrollPageScript(page, command.arguments);
        default:
            throw Error(`Unsupported command ${command.name}`);
    }
};
/**
 * Runs the provided tasks in parallel by chunking them up according to the
 * `parallelism` option and waiting for all chunks to complete.
 */
const runInParallel = async (tasks, config, options) => {
    if (!Array.isArray(tasks) || tasks.length === 0) {
        Promise.reject('Empty task list, nothing to do');
    }
    const parallelism = options?.parallelism || 10;
    const failImmediately = options?.failImmediately || false;
    const tasksArray = tasks;
    const allValues = [];
    for (let i = 0; i < tasksArray.length; i += parallelism) {
        const taskPromises = tasksArray.slice(i, i + parallelism).map(_ => (0, exports.ai)(_, config, options));
        if (failImmediately) {
            const values = await Promise.all(taskPromises);
            for (let i = 0; i < values.length; i++) {
                const value = values[i];
                allValues.push(value);
            }
        }
        else {
            const results = await Promise.allSettled(taskPromises);
            for (let i = 0; i < results.length; i++) {
                const result = results[i];
                allValues.push(result.status === 'fulfilled' ? result.value : result);
            }
        }
    }
    return allValues;
};
const getPrettyCommandName = (rawCommandName) => {
    switch (rawCommandName) {
        case 'clickElement':
        case 'clickLocation':
            return 'click';
        case 'sendKeysToElement':
        case 'clickAndInputLocation':
        case 'sendKeys':
            return 'input';
        case 'hoverElement':
        case 'hoverLocation':
            return 'hover';
        case 'getElementAtLocation':
            return 'getElement';
        case 'keypressEnter':
            return 'pressEnter';
        case 'getDOMSnapshot':
        case 'snapshot':
            return 'analyze';
        default:
            return rawCommandName;
    }
};
//# sourceMappingURL=index.js.map