"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getElementAtLocation = exports.clearStoredCDPElementRef = exports.getStoredCDPElementRef = exports.storeCDPElement = exports.cdpElementToPlaywrightHandle = exports.getSnapshot = exports.getViewportMetadata = exports.scrollElementScript = exports.scrollPageScript = exports.navigate = exports.keypressBackspace = exports.keypressSelectAll = exports.keypressEnter = exports.input = exports.click = exports.hover = exports.clickAndSelectOptionElement = exports.clickAndInputElement = exports.clickElement = exports.hoverElement = exports.clickAndInputLocation = exports.clickLocation = exports.hoverLocation = exports.scrollCDPElement = exports.clickAndInputCDPElement = exports.clickCDPElement = exports.hoverCDPElement = void 0;
const cdp = __importStar(require("./cdp.js"));
// Actions using CDP Element
const hoverCDPElement = async (page, args) => {
    const { centerX, centerY } = await cdp.getContentQuads(page, { backendNodeId: parseInt(args.id) });
    await (0, exports.hoverLocation)(page, { x: centerX, y: centerY });
};
exports.hoverCDPElement = hoverCDPElement;
const clickCDPElement = async (page, args) => {
    const { centerX, centerY } = await cdp.getContentQuads(page, { backendNodeId: parseInt(args.id) });
    await (0, exports.clickLocation)(page, { x: centerX, y: centerY });
};
exports.clickCDPElement = clickCDPElement;
const clickAndInputCDPElement = async (page, args) => {
    const { centerX, centerY } = await cdp.getContentQuads(page, { backendNodeId: parseInt(args.id) });
    await (0, exports.clickAndInputLocation)(page, { x: centerX, y: centerY, value: args.value });
};
exports.clickAndInputCDPElement = clickAndInputCDPElement;
const scrollCDPElement = async (page, args) => {
    const element = await (0, exports.cdpElementToPlaywrightHandle)(page, { backendNodeId: parseInt(args.id) });
    await (0, exports.scrollElementScript)(page, { element, target: args.target });
};
exports.scrollCDPElement = scrollCDPElement;
// Actions using Location
const hoverLocation = async (page, args) => {
    const { element, tagName, isCustomElement } = await (0, exports.getElementAtLocation)(page, args);
    if (!element || tagName === 'CANVAS' || isCustomElement) {
        await (0, exports.hover)(page, args);
    }
    else {
        await (0, exports.hoverElement)(page, { element });
    }
};
exports.hoverLocation = hoverLocation;
const clickLocation = async (page, args) => {
    const { element, tagName, isCustomElement } = await (0, exports.getElementAtLocation)(page, args);
    if (!element || tagName === 'CANVAS' || isCustomElement) {
        await (0, exports.click)(page, args);
    }
    else {
        await (0, exports.clickElement)(page, { element });
    }
};
exports.clickLocation = clickLocation;
const clickAndInputLocation = async (page, args) => {
    const { element, isCustomElement, tagName } = await (0, exports.getElementAtLocation)(page, args);
    if (!element || isCustomElement) {
        await (0, exports.hover)(page, args);
        await (0, exports.click)(page, args);
        await (0, exports.keypressSelectAll)(page);
        await (0, exports.keypressBackspace)(page);
        await (0, exports.input)(page, args);
    }
    else if (tagName === 'SELECT') {
        await (0, exports.clickAndSelectOptionElement)(page, { element, value: args.value });
    }
    else {
        await (0, exports.clickAndInputElement)(page, { element, value: args.value });
    }
};
exports.clickAndInputLocation = clickAndInputLocation;
// Actions using Element
const hoverElement = async (page, args) => {
    await args.element.hover();
};
exports.hoverElement = hoverElement;
const clickElement = async (page, args) => {
    await args.element.hover();
    await args.element.click();
};
exports.clickElement = clickElement;
const clickAndInputElement = async (page, args) => {
    await args.element.hover();
    await args.element.click();
    await args.element.fill(args.value);
};
exports.clickAndInputElement = clickAndInputElement;
const clickAndSelectOptionElement = async (page, args) => {
    await args.element.hover();
    await args.element.click();
    await args.element.selectOption(args.value);
};
exports.clickAndSelectOptionElement = clickAndSelectOptionElement;
// Actions using Device
const hover = async (page, args) => {
    await page.mouse.move(args.x, args.y);
};
exports.hover = hover;
const click = async (page, args) => {
    await page.mouse.move(args.x, args.y);
    await page.mouse.click(args.x, args.y);
};
exports.click = click;
const input = async (page, args) => {
    await page.keyboard.type(args.value);
};
exports.input = input;
const keypressEnter = async (page) => {
    await page.keyboard.press('Enter');
};
exports.keypressEnter = keypressEnter;
const keypressSelectAll = async (page) => {
    await page.keyboard.press('Meta+A');
};
exports.keypressSelectAll = keypressSelectAll;
const keypressBackspace = async (page) => {
    await page.keyboard.press('Backspace');
};
exports.keypressBackspace = keypressBackspace;
const navigate = async (page, args) => {
    await page.goto(args.url);
};
exports.navigate = navigate;
// Actions using Script
const scrollPageScript = async (page, args) => {
    await page.evaluate((evalArgs) => {
        // The viewport should be defined, but if it somehow isn't pick a reasonable default
        const viewportHeight = window.visualViewport?.height ?? 720;
        // For relative scrolls, attempt to scroll by 75% of the viewport height
        const relativeScrollDistance = 0.75 * viewportHeight;
        const elementToScroll = document.scrollingElement || document.body;
        switch (evalArgs.target) {
            case 'top':
                return elementToScroll.scrollTo({ top: 0 });
            case 'bottom':
                return elementToScroll.scrollTo({ top: elementToScroll.scrollHeight });
            case 'up':
                return elementToScroll.scrollBy({ top: -relativeScrollDistance });
            case 'down':
                return elementToScroll.scrollBy({ top: relativeScrollDistance });
            default:
                throw Error(`Unsupported scroll target ${evalArgs.target}`);
        }
    }, args);
};
exports.scrollPageScript = scrollPageScript;
const scrollElementScript = async (page, args) => {
    await args.element.evaluate((element, evalArgs) => {
        // The element height should be defined, but if it somehow isn't pick a reasonable default
        const elementHeight = element.clientHeight ?? 720;
        // For relative scrolls, attempt to scroll by 75% of the element height
        const relativeScrollDistance = 0.75 * elementHeight;
        switch (evalArgs.target) {
            case 'top':
                return element.scrollTo({ top: 0 });
            case 'bottom':
                return element.scrollTo({ top: element.scrollHeight });
            case 'up':
                return element.scrollBy({ top: -relativeScrollDistance });
            case 'down':
                return element.scrollBy({ top: relativeScrollDistance });
            default:
                throw Error(`Unsupported scroll target ${evalArgs.target}`);
        }
    }, args);
};
exports.scrollElementScript = scrollElementScript;
// Meta
const getViewportMetadata = async (page) => {
    const metadata = await page.evaluate(() => {
        return {
            viewportWidth: window.visualViewport?.width || 0,
            viewportHeight: window.visualViewport?.height || 0,
            pixelRatio: window.devicePixelRatio,
        };
    });
    return metadata;
};
exports.getViewportMetadata = getViewportMetadata;
const getSnapshot = async (page) => {
    const domSnapshotPromise = cdp.getDOMSnapshot(page).then((r) => JSON.stringify(r));
    const screenshotPromise = page.screenshot({ scale: 'css' }).then((b) => b.toString('base64'));
    const layoutMetricsPromise = cdp.getLayoutMetrics(page);
    const viewportPromise = (0, exports.getViewportMetadata)(page);
    const [dom, screenshot, { viewportWidth, viewportHeight, pixelRatio }, layoutMetrics,] = await Promise.all([domSnapshotPromise, screenshotPromise, viewportPromise, layoutMetricsPromise]);
    return { dom, screenshot, viewportWidth, viewportHeight, pixelRatio, layoutMetrics };
};
exports.getSnapshot = getSnapshot;
const cdpElementToPlaywrightHandle = async (page, args) => {
    await (0, exports.storeCDPElement)(page, args);
    const element = await (0, exports.getStoredCDPElementRef)(page);
    await (0, exports.clearStoredCDPElementRef)(page);
    return element;
};
exports.cdpElementToPlaywrightHandle = cdpElementToPlaywrightHandle;
const storeCDPElement = async (page, args) => {
    await cdp.runFunctionOn(page, {
        functionDeclaration: `function() { window.$$ZEROSTEP_TEMP_NODE = this }`,
        backendNodeId: args.backendNodeId
    });
};
exports.storeCDPElement = storeCDPElement;
const getStoredCDPElementRef = async (page) => {
    const handle = await page.evaluateHandle(() => window['$$ZEROSTEP_TEMP_NODE']);
    return handle.asElement();
};
exports.getStoredCDPElementRef = getStoredCDPElementRef;
const clearStoredCDPElementRef = async (page) => {
    return await page.evaluateHandle(() => delete window['$$ZEROSTEP_TEMP_NODE']);
};
exports.clearStoredCDPElementRef = clearStoredCDPElementRef;
const getElementAtLocation = async (context, args) => {
    const handle = args.isShadowRoot
        ? await context.evaluateHandle((e, { x, y }) => Reflect.has(e, 'elementFromPoint') ? e.elementFromPoint(x, y) : null, args)
        : await context.evaluateHandle(({ x, y }) => document.elementFromPoint(x, y), args);
    const element = handle.asElement();
    if (!element) {
        return { element: null, tagName: null, isCustomElement: false };
    }
    const tagName = (await element.getProperty('tagName'))?.toString();
    const isCustomElement = tagName.includes('-');
    if (tagName === 'IFRAME') {
        const frame = await element.contentFrame();
        if (frame) {
            const boundingClientRect = await element.evaluate((node) => node.getBoundingClientRect());
            return await (0, exports.getElementAtLocation)(frame, {
                x: args.x - boundingClientRect.x,
                y: args.y - boundingClientRect.y,
            });
        }
    }
    if (isCustomElement) {
        const shadowRootHandle = await element.evaluateHandle((e) => e.shadowRoot);
        const shadowRoot = shadowRootHandle.asElement();
        if (shadowRoot) {
            return await (0, exports.getElementAtLocation)(shadowRoot, {
                x: args.x,
                y: args.y,
                isShadowRoot: true,
            });
        }
    }
    return {
        element,
        tagName,
        isCustomElement,
    };
};
exports.getElementAtLocation = getElementAtLocation;
//# sourceMappingURL=playwright.js.map